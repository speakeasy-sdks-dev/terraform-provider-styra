// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	tfTypes "github.com/StyraInc/terraform-provider-styra/internal/provider/types"
	"github.com/StyraInc/terraform-provider-styra/internal/sdk"
	"github.com/StyraInc/terraform-provider-styra/internal/sdk/models/operations"
	"github.com/StyraInc/terraform-provider-styra/internal/validators"
	speakeasy_boolvalidators "github.com/StyraInc/terraform-provider-styra/internal/validators/boolvalidators"
	speakeasy_listvalidators "github.com/StyraInc/terraform-provider-styra/internal/validators/listvalidators"
	speakeasy_objectvalidators "github.com/StyraInc/terraform-provider-styra/internal/validators/objectvalidators"
	speakeasy_stringvalidators "github.com/StyraInc/terraform-provider-styra/internal/validators/stringvalidators"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"regexp"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ resource.Resource = &SystemResource{}
var _ resource.ResourceWithImportState = &SystemResource{}

func NewSystemResource() resource.Resource {
	return &SystemResource{}
}

// SystemResource defines the resource implementation.
type SystemResource struct {
	client *sdk.StyraDas
}

// SystemResourceModel describes the resource data model.
type SystemResourceModel struct {
	Authz                 tfTypes.SystemsV1AuthzConfig                     `tfsdk:"authz"`
	BundleDownload        *tfTypes.SystemsV1BundleDownloadConfig           `tfsdk:"bundle_download"`
	BundleRegistry        *tfTypes.SystemsV1BundleRegistryConfig           `tfsdk:"bundle_registry"`
	ContextBundleDataOnly types.Bool                                       `tfsdk:"context_bundle_data_only"`
	ContextBundleRoots    []types.String                                   `tfsdk:"context_bundle_roots"`
	Datasources           []tfTypes.SystemsV1DatasourceConfig              `tfsdk:"datasources"`
	DecisionMappings      map[string]tfTypes.SystemsV1RuleDecisionMappings `tfsdk:"decision_mappings"`
	DeploymentParameters  *tfTypes.SystemsV1SystemDeploymentParameters     `tfsdk:"deployment_parameters"`
	Description           types.String                                     `tfsdk:"description"`
	ErrorSetting          types.String                                     `tfsdk:"error_setting"`
	Errors                map[string]tfTypes.SystemsV1AgentErrors          `tfsdk:"errors"`
	ExternalBundles       *tfTypes.SystemsV1ExternalBundleConfig           `tfsdk:"external_bundles"`
	ExternalID            types.String                                     `tfsdk:"external_id"`
	FilterStacks          types.Bool                                       `tfsdk:"filter_stacks"`
	ID                    types.String                                     `tfsdk:"id"`
	KafkaTopic            types.String                                     `tfsdk:"kafka_topic"`
	MatchingStacks        []types.String                                   `tfsdk:"matching_stacks"`
	Metadata              tfTypes.MetaV2ObjectMeta                         `tfsdk:"metadata"`
	MigrationHistory      []tfTypes.SystemsV1MigrationRecord               `tfsdk:"migration_history"`
	MinimumOpaVersion     types.String                                     `tfsdk:"minimum_opa_version"`
	MockOpaEnabled        types.Bool                                       `tfsdk:"mock_opa_enabled"`
	Name                  types.String                                     `tfsdk:"name"`
	Policies              []tfTypes.SystemsV1PolicyConfig                  `tfsdk:"policies"`
	ReadOnly              types.Bool                                       `tfsdk:"read_only"`
	Recursive             types.String                                     `tfsdk:"recursive"`
	RequestID             types.String                                     `tfsdk:"request_id"`
	Result                tfTypes.SystemsV1SystemConfig                    `tfsdk:"result"`
	SourceControl         *tfTypes.GitV1SourceControlConfig                `tfsdk:"source_control"`
	Status                types.String                                     `tfsdk:"status"`
	Tokens                []tfTypes.TokensV1Token                          `tfsdk:"tokens"`
	Type                  types.String                                     `tfsdk:"type"`
	TypeParameters        *tfTypes.TypeParameters                          `tfsdk:"type_parameters"`
	Uninstall             map[string]types.String                          `tfsdk:"uninstall"`
}

func (r *SystemResource) Metadata(ctx context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_system"
}

func (r *SystemResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "System Resource",
		Attributes: map[string]schema.Attribute{
			"authz": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"role_bindings": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									Computed:    true,
									Description: `role binding ID`,
								},
								"role_name": schema.StringAttribute{
									Computed:    true,
									Description: `role name`,
								},
							},
						},
						Description: `a list of role binding configs`,
					},
				},
			},
			"bundle_download": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"delta_bundles": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `enabled delta bundles on bundle download. Default: false`,
					},
				},
			},
			"bundle_registry": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"disable_bundle_compatibility_check": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Description: `when checked, bundles will be activated regardless of their compatibility with currently running agents`,
					},
					"distribution_s3": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"access_keys": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `access key id and secret access key are looked under the key <name>/<access_keys>`,
							},
							"bucket": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `bucket name. Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"context_path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString("context-{policy_path}"),
								Description: `context bundle path. The name must not use template variables. Default: "context-{policy_path}"`,
							},
							"discovery_path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString("discovery.tgz"),
								Description: `discovery bundle path. Template variables can be used in the name. Default: "discovery.tgz"`,
							},
							"endpoint": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `AWS endpoint`,
							},
							"opa_credentials": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"environment_credentials": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
									},
									"metadata_credentials": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"aws_region": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Not Null`,
												Validators: []validator.String{
													speakeasy_stringvalidators.NotNull(),
												},
											},
											"iam_role": schema.StringAttribute{
												Computed: true,
												Optional: true,
											},
										},
									},
									"web_identity_credentials": schema.SingleNestedAttribute{
										Computed: true,
										Optional: true,
										Attributes: map[string]schema.Attribute{
											"aws_region": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Not Null`,
												Validators: []validator.String{
													speakeasy_stringvalidators.NotNull(),
												},
											},
											"session_name": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Not Null`,
												Validators: []validator.String{
													speakeasy_stringvalidators.NotNull(),
												},
											},
										},
									},
								},
							},
							"policy_path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Default:     stringdefault.StaticString("bundle.tgz"),
								Description: `policy bundle path. Template variables can be used in the name. Default: "bundle.tgz"`,
							},
							"region": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `AWS region. Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"role_arn": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `AWS role`,
							},
						},
					},
					"entrypoints": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						ElementType: types.StringType,
						Description: `extra bundle entry points to use when compiling bundles`,
					},
					"manual_deployment": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Description: `manual deployment mode to prevent automatic deployment of new bundles`,
					},
					"manual_deployment_overrides": schema.MapAttribute{
						Computed:    true,
						Optional:    true,
						ElementType: types.BoolType,
						Description: `Override of manual deployment mode flag per bundle type`,
					},
					"max_bundles": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Description: `maximum number of all bundles to store`,
					},
					"max_deployed_bundles": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Description: `maximum number of previously deployed bundles to store`,
					},
					"optimization_level": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Description: `OPA optimization level to use when building bundles`,
					},
				},
			},
			"context_bundle_data_only": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `only put data in the context bundle`,
			},
			"context_bundle_roots": schema.ListAttribute{
				Computed:    true,
				Optional:    true,
				ElementType: types.StringType,
				Description: `list of path prefixes for policies/datasources that go into the second (context) bundle`,
			},
			"datasources": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"category": schema.StringAttribute{
							Computed:    true,
							Description: `datasource category`,
						},
						"id": schema.StringAttribute{
							Computed:    true,
							Description: `datasource ID`,
						},
						"optional": schema.BoolAttribute{
							Computed:    true,
							Description: `optional datasources can be deleted without being recreated automatically`,
						},
						"status": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"code": schema.StringAttribute{
									Computed: true,
								},
								"message": schema.StringAttribute{
									Computed: true,
								},
								"timestamp": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
							},
						},
					},
				},
				Description: `datasources created for the system`,
			},
			"decision_mappings": schema.MapNestedAttribute{
				Computed: true,
				Optional: true,
				NestedObject: schema.NestedAttributeObject{
					Validators: []validator.Object{
						speakeasy_objectvalidators.NotNull(),
					},
					Attributes: map[string]schema.Attribute{
						"allowed": schema.SingleNestedAttribute{
							Computed: true,
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"expected": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `Parsed as JSON.`,
									Validators: []validator.String{
										validators.IsValidJSON(),
									},
								},
								"negated": schema.BoolAttribute{
									Computed:    true,
									Optional:    true,
									Default:     booldefault.StaticBool(false),
									Description: `when set to true, decision is Allowed when the mapped property IS NOT equal to the expected value. Default: false`,
								},
								"path": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `dot-separated decision property path. Not Null`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						"columns": schema.ListNestedAttribute{
							Computed: true,
							Optional: true,
							NestedObject: schema.NestedAttributeObject{
								Validators: []validator.Object{
									speakeasy_objectvalidators.NotNull(),
								},
								Attributes: map[string]schema.Attribute{
									"key": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Description: `column key (also the search key). Not Null`,
										Validators: []validator.String{
											speakeasy_stringvalidators.NotNull(),
										},
									},
									"path": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Description: `dot-separated decision property path. Not Null`,
										Validators: []validator.String{
											speakeasy_stringvalidators.NotNull(),
										},
									},
									"type": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Default:     stringdefault.StaticString("string"),
										Description: `column type: one of "string", "boolean", "date", "integer", "float". Default: "string"`,
									},
								},
							},
							Description: `decision mappings for additional columns`,
						},
						"reason": schema.SingleNestedAttribute{
							Computed: true,
							Optional: true,
							Attributes: map[string]schema.Attribute{
								"path": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `dot-separated decision property path. Not Null`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
					},
				},
				Description: `location of key attributes and additional columns in the decisions grouped by policy entry point path`,
			},
			"deployment_parameters": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"deny_on_opa_fail": schema.BoolAttribute{
						Computed:    true,
						Optional:    true,
						Default:     booldefault.StaticBool(false),
						Description: `true to fail close. Default: false`,
					},
					"discovery": schema.SingleNestedAttribute{
						Computed:    true,
						Optional:    true,
						Description: `discovery config settings for OPAs linked to the system. (in case of conflict with system-type defined setting, this value takes precedence)`,
					},
					"extra": schema.SingleNestedAttribute{
						Computed:    true,
						Optional:    true,
						Description: `extra deployment settings`,
					},
					"http_proxy": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `HTTP proxy URL`,
					},
					"https_proxy": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `HTTPS proxy URL`,
					},
					"kubernetes_version": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `minimum Kubernetes version expected (where applicable)`,
					},
					"mutating_webhook_name": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Custom name for mutating webhook (useful for changing webhook order of execution)`,
					},
					"namespace": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `Kubernetes namespace the system is deployed to`,
					},
					"no_proxy": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `URLs that should be excluded from proxying`,
					},
					"timeout_seconds": schema.Int64Attribute{
						Computed:    true,
						Optional:    true,
						Description: `Kubernetes webhook timeout (where applicable)`,
					},
					"trusted_ca_certs": schema.ListAttribute{
						Computed:    true,
						Optional:    true,
						ElementType: types.StringType,
						Description: `trusted CA certificates`,
					},
					"trusted_container_registry": schema.StringAttribute{
						Computed:    true,
						Optional:    true,
						Description: `trusted container registry`,
					},
				},
			},
			"description": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `description for the system`,
			},
			"error_setting": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `error/warning configuration: one of "all", "errors", "none"`,
			},
			"errors": schema.MapNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"errors": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"code": schema.StringAttribute{
										Computed: true,
									},
									"message": schema.StringAttribute{
										Computed: true,
									},
									"timestamp": schema.StringAttribute{
										Computed: true,
										Validators: []validator.String{
											validators.IsRFC3339(),
										},
									},
								},
							},
							Description: `list of system errors`,
						},
						"waiting": schema.BoolAttribute{
							Computed:    true,
							Description: `true if the the system is waiting for error to be resolved`,
						},
					},
				},
				Description: `current deployment errors`,
			},
			"external_bundles": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"bundles": schema.MapNestedAttribute{
						Computed: true,
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							Attributes: map[string]schema.Attribute{
								"persist": schema.BoolAttribute{
									Computed:    true,
									Optional:    true,
									Description: `persist activated bundles to disk`,
								},
								"polling": schema.SingleNestedAttribute{
									Computed: true,
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"long_polling_timeout_seconds": schema.Int64Attribute{
											Computed:    true,
											Optional:    true,
											Description: `maximum amount of time the server should wait before issuing a timeout if there’s no update available`,
										},
										"max_delay_seconds": schema.Int64Attribute{
											Computed:    true,
											Optional:    true,
											Description: `maximum amount of time to wait between bundle downloads`,
										},
										"min_delay_seconds": schema.Int64Attribute{
											Computed:    true,
											Optional:    true,
											Description: `minimum amount of time to wait between bundle downloads`,
										},
									},
								},
								"resource": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `resource path to use to download bundle from configured service`,
								},
								"service": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `name of service to use to contact remote server. Not Null`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"signing": schema.SingleNestedAttribute{
									Computed: true,
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"exclude_files": schema.ListAttribute{
											Computed:    true,
											Optional:    true,
											ElementType: types.StringType,
											Description: `files in the bundle to exclude during verification`,
										},
										"keyid": schema.StringAttribute{
											Computed:    true,
											Optional:    true,
											Description: `name of the key to use for bundle signature verification`,
										},
										"public_keys": schema.MapNestedAttribute{
											Computed: true,
											Optional: true,
											NestedObject: schema.NestedAttributeObject{
												Validators: []validator.Object{
													speakeasy_objectvalidators.NotNull(),
												},
												Attributes: map[string]schema.Attribute{
													"algorithm": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `name of the signing algorithm`,
													},
													"key": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `PEM encoded public key to use for signature verification`,
													},
													"private_key": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `PEM encoded private key to use for signing`,
													},
													"scope": schema.StringAttribute{
														Computed:    true,
														Optional:    true,
														Description: `scope to use for bundle signature verification`,
													},
												},
											},
											Description: `information about necessary public signing keys`,
										},
										"scope": schema.StringAttribute{
											Computed:    true,
											Optional:    true,
											Description: `scope to use for bundle signature verification`,
										},
									},
								},
								"size_limit_bytes": schema.Int64Attribute{
									Computed:    true,
									Optional:    true,
									Description: `size limit for individual files contained in the bundle`,
								},
							},
						},
						Description: `externally configured bundles, use name of bundle as key`,
					},
					"services": schema.ListNestedAttribute{
						Computed: true,
						Optional: true,
						NestedObject: schema.NestedAttributeObject{
							Validators: []validator.Object{
								speakeasy_objectvalidators.NotNull(),
							},
							Attributes: map[string]schema.Attribute{
								"allow_insecure_tls": schema.BoolAttribute{
									Computed:    true,
									Optional:    true,
									Description: `allow insecure TLS`,
								},
								"credentials": schema.SingleNestedAttribute{
									Computed: true,
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"azure_managed_identity": schema.SingleNestedAttribute{
											Computed: true,
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"api_version": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `API version to use. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"client_id": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `optional client ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"endpoint": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `request endpoint. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"mi_res_id": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `optional Azure Resource ID of the managed identity you would like the token for, required, if your VM has multiple user-assigned managed identities. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"object_id": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `optional object ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"resource": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `app ID URI of the target resource. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
											},
										},
										"bearer": schema.SingleNestedAttribute{
											Computed: true,
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"scheme": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `bearer token scheme to specify`,
												},
												"token": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `enables token-based authentication and supplies the bearer token to authenticate with. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"token_path": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `enables token-based authentication and supplies the path to the bearer token to authenticate with. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
											},
										},
										"client_tls": schema.SingleNestedAttribute{
											Computed: true,
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"cert": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `the path to the client certificate to authenticate with. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"private_key": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `the path to the private key of the client certificate. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"private_key_passphrase": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `the passphrase to use for the private key`,
												},
											},
										},
										"gcp_metadata": schema.SingleNestedAttribute{
											Computed: true,
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"access_token_path": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `the access token metadata path to use. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"audience": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `the audience to use when fetching identity tokens. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"endpoint": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `the metadata endpoint to use. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"id_token_path": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `the identity token metadata path to use. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"scopes": schema.ListAttribute{
													Computed:    true,
													Optional:    true,
													ElementType: types.StringType,
													Description: `the set of scopes to use when fetching access token. Not Null`,
													Validators: []validator.List{
														speakeasy_listvalidators.NotNull(),
													},
												},
											},
										},
										"oauth2": schema.SingleNestedAttribute{
											Computed: true,
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"additional_claims": schema.SingleNestedAttribute{
													Computed:    true,
													Optional:    true,
													Description: `map of claims to include in the JWT. Not Null`,
													Validators: []validator.Object{
														speakeasy_objectvalidators.NotNull(),
													},
												},
												"additional_headers": schema.MapAttribute{
													Computed:    true,
													Optional:    true,
													ElementType: types.StringType,
													Description: `map of additional headers to send to token endpoint at the OAuth2 authorization server`,
												},
												"additional_parameters": schema.MapAttribute{
													Computed:    true,
													Optional:    true,
													ElementType: types.StringType,
													Description: `map of additional body parameters to send token endpoint at the OAuth2 authorization server`,
												},
												"client_id": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `the client ID to use for authentication. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"client_secret": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `the client secret to use for authentication. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"grant_type": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `defaults to client_credentials. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"include_jti_claim": schema.BoolAttribute{
													Computed:    true,
													Optional:    true,
													Description: `include a uniquely generated jti claim in any issued JWT. Not Null`,
													Validators: []validator.Bool{
														speakeasy_boolvalidators.NotNull(),
													},
												},
												"scopes": schema.ListAttribute{
													Computed:    true,
													Optional:    true,
													ElementType: types.StringType,
													Description: `optional list of scopes to request for the token`,
												},
												"signing_key": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `reference to private key used for signing the JWT. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"thumbprint": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `certificate thumbprint to use for x5t header generation. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
												"token_url": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `URL pointing to the token endpoint at the OAuth2 authorization server. Not Null`,
													Validators: []validator.String{
														speakeasy_stringvalidators.NotNull(),
													},
												},
											},
										},
										"plugin": schema.StringAttribute{
											Computed:    true,
											Optional:    true,
											Description: `authenticate using a custom plugin`,
										},
										"s3_signing": schema.SingleNestedAttribute{
											Computed: true,
											Optional: true,
											Attributes: map[string]schema.Attribute{
												"environment_credentials": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `Parsed as JSON.`,
													Validators: []validator.String{
														validators.IsValidJSON(),
													},
												},
												"metadata_credentials": schema.SingleNestedAttribute{
													Computed: true,
													Optional: true,
													Attributes: map[string]schema.Attribute{
														"aws_region": schema.StringAttribute{
															Computed:    true,
															Optional:    true,
															Description: `the AWS region to use for the AWS signing service credential method. Not Null`,
															Validators: []validator.String{
																speakeasy_stringvalidators.NotNull(),
															},
														},
														"iam_role": schema.StringAttribute{
															Computed:    true,
															Optional:    true,
															Description: `the IAM role to use for the AWS signing service credential method`,
														},
													},
												},
												"profile_credentials": schema.SingleNestedAttribute{
													Computed: true,
													Optional: true,
													Attributes: map[string]schema.Attribute{
														"aws_region": schema.StringAttribute{
															Computed:    true,
															Optional:    true,
															Description: `the AWS region to use for the AWS signing service credential method. Not Null`,
															Validators: []validator.String{
																speakeasy_stringvalidators.NotNull(),
															},
														},
														"path": schema.StringAttribute{
															Computed:    true,
															Optional:    true,
															Description: `the path to the shared credentials file`,
														},
														"profile": schema.StringAttribute{
															Computed:    true,
															Optional:    true,
															Description: `AWS Profile to extract credentials from the credentials file`,
														},
													},
												},
												"service": schema.StringAttribute{
													Computed:    true,
													Optional:    true,
													Description: `the AWS service to sign requests with, eg execute-api or s3 (default: s3)`,
												},
												"web_identity_credentials": schema.SingleNestedAttribute{
													Computed: true,
													Optional: true,
													Attributes: map[string]schema.Attribute{
														"aws_region": schema.StringAttribute{
															Computed:    true,
															Optional:    true,
															Description: `the AWS region to use for the sts regional endpoint (default: global). Not Null`,
															Validators: []validator.String{
																speakeasy_stringvalidators.NotNull(),
															},
														},
														"session_name": schema.StringAttribute{
															Computed:    true,
															Optional:    true,
															Description: `the session name used to identify the assumed role session (default: open-policy-agent). Not Null`,
															Validators: []validator.String{
																speakeasy_stringvalidators.NotNull(),
															},
														},
													},
												},
											},
										},
									},
								},
								"headers": schema.MapAttribute{
									Computed:    true,
									Optional:    true,
									ElementType: types.StringType,
									Description: `HTTP headers to include in the requests to the service`,
								},
								"keys": schema.MapNestedAttribute{
									Computed: true,
									Optional: true,
									NestedObject: schema.NestedAttributeObject{
										Validators: []validator.Object{
											speakeasy_objectvalidators.NotNull(),
										},
										Attributes: map[string]schema.Attribute{
											"algorithm": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Not Null`,
												Validators: []validator.String{
													speakeasy_stringvalidators.NotNull(),
												},
											},
											"key": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Not Null`,
												Validators: []validator.String{
													speakeasy_stringvalidators.NotNull(),
												},
											},
											"private_key": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Not Null`,
												Validators: []validator.String{
													speakeasy_stringvalidators.NotNull(),
												},
											},
											"scope": schema.StringAttribute{
												Computed:    true,
												Optional:    true,
												Description: `Not Null`,
												Validators: []validator.String{
													speakeasy_stringvalidators.NotNull(),
												},
											},
										},
									},
									Description: `keys is a dictionary mapping the key name to the actual key and optionally the algorithm and scope.`,
								},
								"name": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `unique name for each service, referred to by plugins. Not Null`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
								"response_header_timeout_seconds": schema.Int64Attribute{
									Computed:    true,
									Optional:    true,
									Description: `amount of time to wait for a server's response headers after fully writing the request`,
								},
								"tls": schema.SingleNestedAttribute{
									Computed: true,
									Optional: true,
									Attributes: map[string]schema.Attribute{
										"ca_cert": schema.StringAttribute{
											Computed:    true,
											Optional:    true,
											Description: `the path to the root CA certificate. If not provided, this defaults to TLS using the host’s root CA set`,
										},
										"system_ca_required": schema.BoolAttribute{
											Computed:    true,
											Optional:    true,
											Description: `require system certificate appended with root CA certificate`,
										},
									},
								},
								"type": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `optional parameter that allows to use an “OCI” service type`,
								},
								"url": schema.StringAttribute{
									Computed:    true,
									Optional:    true,
									Description: `base URL to contact the service with. Not Null`,
									Validators: []validator.String{
										speakeasy_stringvalidators.NotNull(),
									},
								},
							},
						},
						Description: `externally configured services. Not Null`,
						Validators: []validator.List{
							speakeasy_listvalidators.NotNull(),
						},
					},
				},
			},
			"external_id": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `optional parameter to map Styra DAS system ID to external IDs used by a customer. (mapping can be retrieved with TranslateExternalIds operation)`,
			},
			"filter_stacks": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `when set, stacks that are not linked to this system will be filtered out of its bundles`,
			},
			"id": schema.StringAttribute{
				Computed:    true,
				Description: `system ID`,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile(`.*`), "must match pattern "+regexp.MustCompile(`.*`).String()),
				},
			},
			"kafka_topic": schema.StringAttribute{
				Computed:    true,
				Optional:    true,
				Description: `optional parameter to specify the Kafka topic where the decision logs for this system should be published (ignored if Kafka is not configured for the workspace for decision export)`,
			},
			"matching_stacks": schema.ListAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `IDs of stacks matching the system`,
			},
			"metadata": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"created_at": schema.StringAttribute{
						Computed: true,
						Validators: []validator.String{
							validators.IsRFC3339(),
						},
					},
					"created_by": schema.StringAttribute{
						Computed: true,
					},
					"created_through": schema.StringAttribute{
						Computed: true,
					},
					"last_modified_at": schema.StringAttribute{
						Computed: true,
						Validators: []validator.String{
							validators.IsRFC3339(),
						},
					},
					"last_modified_by": schema.StringAttribute{
						Computed: true,
					},
					"last_modified_through": schema.StringAttribute{
						Computed: true,
					},
				},
			},
			"migration_history": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"from": schema.StringAttribute{
							Computed: true,
						},
						"initiated_by": schema.StringAttribute{
							Computed: true,
						},
						"initiating_user": schema.StringAttribute{
							Computed: true,
						},
						"migrated_at": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"recovered": schema.BoolAttribute{
							Computed: true,
						},
						"to": schema.StringAttribute{
							Computed: true,
						},
					},
				},
				Description: `A history of any migrations performed on this system`,
			},
			"minimum_opa_version": schema.StringAttribute{
				Computed:    true,
				Description: `minimum running OPA version for the systems`,
			},
			"mock_opa_enabled": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Description: `enable mock OPAs for this system`,
			},
			"name": schema.StringAttribute{
				Required:    true,
				Description: `system name`,
			},
			"policies": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"created": schema.StringAttribute{
							Computed:    true,
							Description: `policy on when to (re)generate the policy`,
						},
						"enforcement": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"enforced": schema.BoolAttribute{
									Computed:    true,
									Description: `true if the policy is enforced`,
								},
								"type": schema.StringAttribute{
									Computed:    true,
									Description: `enforcement type e.g. opa, test, mask`,
								},
							},
						},
						"id": schema.StringAttribute{
							Computed:    true,
							Description: `policy ID (path)`,
						},
						"modules": schema.ListNestedAttribute{
							Computed: true,
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"name": schema.StringAttribute{
										Computed:    true,
										Description: `module name`,
									},
									"placeholder": schema.BoolAttribute{
										Computed:    true,
										Default:     booldefault.StaticBool(false),
										Description: `module is a placeholder. Default: false`,
									},
									"read_only": schema.BoolAttribute{
										Computed:    true,
										Description: `true if module is read-only`,
									},
									"rules": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"allow": schema.Int64Attribute{
												Computed:    true,
												Description: `number of allow rules`,
											},
											"deny": schema.Int64Attribute{
												Computed:    true,
												Description: `number of deny rules`,
											},
											"enforce": schema.Int64Attribute{
												Computed:    true,
												Description: `number of enforce rules`,
											},
											"ignore": schema.Int64Attribute{
												Computed:    true,
												Description: `number of ignore rules`,
											},
											"monitor": schema.Int64Attribute{
												Computed:    true,
												Description: `number of monitor rules`,
											},
											"notify": schema.Int64Attribute{
												Computed:    true,
												Description: `number of notify rules`,
											},
											"other": schema.Int64Attribute{
												Computed:    true,
												Description: `number of unclassified rules`,
											},
											"test": schema.Int64Attribute{
												Computed:    true,
												Description: `number of test rules`,
											},
											"total": schema.Int64Attribute{
												Computed:    true,
												Description: `total number of rules`,
											},
										},
									},
								},
							},
							Description: `rego modules policy consists of`,
						},
						"rules": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"allow": schema.Int64Attribute{
									Computed:    true,
									Description: `number of allow rules`,
								},
								"deny": schema.Int64Attribute{
									Computed:    true,
									Description: `number of deny rules`,
								},
								"enforce": schema.Int64Attribute{
									Computed:    true,
									Description: `number of enforce rules`,
								},
								"ignore": schema.Int64Attribute{
									Computed:    true,
									Description: `number of ignore rules`,
								},
								"monitor": schema.Int64Attribute{
									Computed:    true,
									Description: `number of monitor rules`,
								},
								"notify": schema.Int64Attribute{
									Computed:    true,
									Description: `number of notify rules`,
								},
								"other": schema.Int64Attribute{
									Computed:    true,
									Description: `number of unclassified rules`,
								},
								"test": schema.Int64Attribute{
									Computed:    true,
									Description: `number of test rules`,
								},
								"total": schema.Int64Attribute{
									Computed:    true,
									Description: `total number of rules`,
								},
							},
						},
						"type": schema.StringAttribute{
							Computed:    true,
							Description: `policy type e.g. validating/rules`,
						},
					},
				},
				Description: `policies created for the system`,
			},
			"read_only": schema.BoolAttribute{
				Computed:    true,
				Optional:    true,
				Default:     booldefault.StaticBool(false),
				Description: `prevents users from modifying policies using Styra UIs. Default: false`,
			},
			"recursive": schema.StringAttribute{
				Optional:    true,
				Description: `if set to 'false', only deletes the system configuration and does not delete associated objects`,
			},
			"request_id": schema.StringAttribute{
				Computed: true,
			},
			"result": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"authz": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"role_bindings": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"id": schema.StringAttribute{
											Computed:    true,
											Description: `role binding ID`,
										},
										"role_name": schema.StringAttribute{
											Computed:    true,
											Description: `role name`,
										},
									},
								},
								Description: `a list of role binding configs`,
							},
						},
					},
					"bundle_download": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"delta_bundles": schema.BoolAttribute{
								Computed:    true,
								Default:     booldefault.StaticBool(false),
								Description: `enabled delta bundles on bundle download. Default: false`,
							},
						},
					},
					"bundle_registry": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"disable_bundle_compatibility_check": schema.BoolAttribute{
								Computed:    true,
								Description: `when checked, bundles will be activated regardless of their compatibility with currently running agents`,
							},
							"distribution_s3": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"access_keys": schema.StringAttribute{
										Computed:    true,
										Description: `access key id and secret access key are looked under the key <name>/<access_keys>`,
									},
									"bucket": schema.StringAttribute{
										Computed:    true,
										Description: `bucket name`,
									},
									"context_path": schema.StringAttribute{
										Computed:    true,
										Default:     stringdefault.StaticString("context-{policy_path}"),
										Description: `context bundle path. The name must not use template variables. Default: "context-{policy_path}"`,
									},
									"discovery_path": schema.StringAttribute{
										Computed:    true,
										Default:     stringdefault.StaticString("discovery.tgz"),
										Description: `discovery bundle path. Template variables can be used in the name. Default: "discovery.tgz"`,
									},
									"endpoint": schema.StringAttribute{
										Computed:    true,
										Description: `AWS endpoint`,
									},
									"opa_credentials": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"environment_credentials": schema.SingleNestedAttribute{
												Computed: true,
											},
											"metadata_credentials": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"aws_region": schema.StringAttribute{
														Computed: true,
													},
													"iam_role": schema.StringAttribute{
														Computed: true,
													},
												},
											},
											"web_identity_credentials": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"aws_region": schema.StringAttribute{
														Computed: true,
													},
													"session_name": schema.StringAttribute{
														Computed: true,
													},
												},
											},
										},
									},
									"policy_path": schema.StringAttribute{
										Computed:    true,
										Default:     stringdefault.StaticString("bundle.tgz"),
										Description: `policy bundle path. Template variables can be used in the name. Default: "bundle.tgz"`,
									},
									"region": schema.StringAttribute{
										Computed:    true,
										Description: `AWS region`,
									},
									"role_arn": schema.StringAttribute{
										Computed:    true,
										Description: `AWS role`,
									},
								},
							},
							"entrypoints": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `extra bundle entry points to use when compiling bundles`,
							},
							"manual_deployment": schema.BoolAttribute{
								Computed:    true,
								Description: `manual deployment mode to prevent automatic deployment of new bundles`,
							},
							"manual_deployment_overrides": schema.MapAttribute{
								Computed:    true,
								ElementType: types.BoolType,
								Description: `Override of manual deployment mode flag per bundle type`,
							},
							"max_bundles": schema.Int64Attribute{
								Computed:    true,
								Description: `maximum number of all bundles to store`,
							},
							"max_deployed_bundles": schema.Int64Attribute{
								Computed:    true,
								Description: `maximum number of previously deployed bundles to store`,
							},
							"optimization_level": schema.Int64Attribute{
								Computed:    true,
								Description: `OPA optimization level to use when building bundles`,
							},
						},
					},
					"context_bundle_data_only": schema.BoolAttribute{
						Computed:    true,
						Description: `only put data in the context bundle`,
					},
					"context_bundle_roots": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `list of path prefixes for policies/datasources that go into the second (context) bundle`,
					},
					"datasources": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"category": schema.StringAttribute{
									Computed:    true,
									Description: `datasource category`,
								},
								"id": schema.StringAttribute{
									Computed:    true,
									Description: `datasource ID`,
								},
								"optional": schema.BoolAttribute{
									Computed:    true,
									Description: `optional datasources can be deleted without being recreated automatically`,
								},
								"status": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"code": schema.StringAttribute{
											Computed: true,
										},
										"message": schema.StringAttribute{
											Computed: true,
										},
										"timestamp": schema.StringAttribute{
											Computed: true,
											Validators: []validator.String{
												validators.IsRFC3339(),
											},
										},
									},
								},
							},
						},
						Description: `datasources created for the system`,
					},
					"decision_mappings": schema.MapNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"allowed": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"expected": schema.StringAttribute{
											Computed:    true,
											Description: `Parsed as JSON.`,
											Validators: []validator.String{
												validators.IsValidJSON(),
											},
										},
										"negated": schema.BoolAttribute{
											Computed:    true,
											Default:     booldefault.StaticBool(false),
											Description: `when set to true, decision is Allowed when the mapped property IS NOT equal to the expected value. Default: false`,
										},
										"path": schema.StringAttribute{
											Computed:    true,
											Description: `dot-separated decision property path`,
										},
									},
								},
								"columns": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"key": schema.StringAttribute{
												Computed:    true,
												Description: `column key (also the search key)`,
											},
											"path": schema.StringAttribute{
												Computed:    true,
												Description: `dot-separated decision property path`,
											},
											"type": schema.StringAttribute{
												Computed:    true,
												Default:     stringdefault.StaticString("string"),
												Description: `column type: one of "string", "boolean", "date", "integer", "float". Default: "string"`,
											},
										},
									},
									Description: `decision mappings for additional columns`,
								},
								"reason": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											Computed:    true,
											Description: `dot-separated decision property path`,
										},
									},
								},
							},
						},
						Description: `location of key attributes and additional columns in the decisions grouped by policy entry point path`,
					},
					"deployment_parameters": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"deny_on_opa_fail": schema.BoolAttribute{
								Computed:    true,
								Default:     booldefault.StaticBool(false),
								Description: `true to fail close. Default: false`,
							},
							"discovery": schema.SingleNestedAttribute{
								Computed:    true,
								Description: `discovery config settings for OPAs linked to the system. (in case of conflict with system-type defined setting, this value takes precedence)`,
							},
							"extra": schema.SingleNestedAttribute{
								Computed:    true,
								Description: `extra deployment settings`,
							},
							"http_proxy": schema.StringAttribute{
								Computed:    true,
								Description: `HTTP proxy URL`,
							},
							"https_proxy": schema.StringAttribute{
								Computed:    true,
								Description: `HTTPS proxy URL`,
							},
							"kubernetes_version": schema.StringAttribute{
								Computed:    true,
								Description: `minimum Kubernetes version expected (where applicable)`,
							},
							"mutating_webhook_name": schema.StringAttribute{
								Computed:    true,
								Description: `Custom name for mutating webhook (useful for changing webhook order of execution)`,
							},
							"namespace": schema.StringAttribute{
								Computed:    true,
								Description: `Kubernetes namespace the system is deployed to`,
							},
							"no_proxy": schema.StringAttribute{
								Computed:    true,
								Description: `URLs that should be excluded from proxying`,
							},
							"timeout_seconds": schema.Int64Attribute{
								Computed:    true,
								Description: `Kubernetes webhook timeout (where applicable)`,
							},
							"trusted_ca_certs": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `trusted CA certificates`,
							},
							"trusted_container_registry": schema.StringAttribute{
								Computed:    true,
								Description: `trusted container registry`,
							},
						},
					},
					"description": schema.StringAttribute{
						Computed:    true,
						Description: `description for the system`,
					},
					"error_setting": schema.StringAttribute{
						Computed:    true,
						Description: `error/warning configuration: one of "all", "errors", "none"`,
					},
					"errors": schema.MapNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"errors": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"code": schema.StringAttribute{
												Computed: true,
											},
											"message": schema.StringAttribute{
												Computed: true,
											},
											"timestamp": schema.StringAttribute{
												Computed: true,
												Validators: []validator.String{
													validators.IsRFC3339(),
												},
											},
										},
									},
									Description: `list of system errors`,
								},
								"waiting": schema.BoolAttribute{
									Computed:    true,
									Description: `true if the the system is waiting for error to be resolved`,
								},
							},
						},
						Description: `current deployment errors`,
					},
					"external_bundles": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"bundles": schema.MapNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"persist": schema.BoolAttribute{
											Computed:    true,
											Description: `persist activated bundles to disk`,
										},
										"polling": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"long_polling_timeout_seconds": schema.Int64Attribute{
													Computed:    true,
													Description: `maximum amount of time the server should wait before issuing a timeout if there’s no update available`,
												},
												"max_delay_seconds": schema.Int64Attribute{
													Computed:    true,
													Description: `maximum amount of time to wait between bundle downloads`,
												},
												"min_delay_seconds": schema.Int64Attribute{
													Computed:    true,
													Description: `minimum amount of time to wait between bundle downloads`,
												},
											},
										},
										"resource": schema.StringAttribute{
											Computed:    true,
											Description: `resource path to use to download bundle from configured service`,
										},
										"service": schema.StringAttribute{
											Computed:    true,
											Description: `name of service to use to contact remote server`,
										},
										"signing": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"exclude_files": schema.ListAttribute{
													Computed:    true,
													ElementType: types.StringType,
													Description: `files in the bundle to exclude during verification`,
												},
												"keyid": schema.StringAttribute{
													Computed:    true,
													Description: `name of the key to use for bundle signature verification`,
												},
												"public_keys": schema.MapNestedAttribute{
													Computed: true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"algorithm": schema.StringAttribute{
																Computed:    true,
																Description: `name of the signing algorithm`,
															},
															"key": schema.StringAttribute{
																Computed:    true,
																Description: `PEM encoded public key to use for signature verification`,
															},
															"private_key": schema.StringAttribute{
																Computed:    true,
																Description: `PEM encoded private key to use for signing`,
															},
															"scope": schema.StringAttribute{
																Computed:    true,
																Description: `scope to use for bundle signature verification`,
															},
														},
													},
													Description: `information about necessary public signing keys`,
												},
												"scope": schema.StringAttribute{
													Computed:    true,
													Description: `scope to use for bundle signature verification`,
												},
											},
										},
										"size_limit_bytes": schema.Int64Attribute{
											Computed:    true,
											Description: `size limit for individual files contained in the bundle`,
										},
									},
								},
								Description: `externally configured bundles, use name of bundle as key`,
							},
							"services": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"allow_insecure_tls": schema.BoolAttribute{
											Computed:    true,
											Description: `allow insecure TLS`,
										},
										"credentials": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"azure_managed_identity": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"api_version": schema.StringAttribute{
															Computed:    true,
															Description: `API version to use`,
														},
														"client_id": schema.StringAttribute{
															Computed:    true,
															Description: `optional client ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities`,
														},
														"endpoint": schema.StringAttribute{
															Computed:    true,
															Description: `request endpoint`,
														},
														"mi_res_id": schema.StringAttribute{
															Computed:    true,
															Description: `optional Azure Resource ID of the managed identity you would like the token for, required, if your VM has multiple user-assigned managed identities`,
														},
														"object_id": schema.StringAttribute{
															Computed:    true,
															Description: `optional object ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities`,
														},
														"resource": schema.StringAttribute{
															Computed:    true,
															Description: `app ID URI of the target resource`,
														},
													},
												},
												"bearer": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"scheme": schema.StringAttribute{
															Computed:    true,
															Description: `bearer token scheme to specify`,
														},
														"token": schema.StringAttribute{
															Computed:    true,
															Description: `enables token-based authentication and supplies the bearer token to authenticate with`,
														},
														"token_path": schema.StringAttribute{
															Computed:    true,
															Description: `enables token-based authentication and supplies the path to the bearer token to authenticate with`,
														},
													},
												},
												"client_tls": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"cert": schema.StringAttribute{
															Computed:    true,
															Description: `the path to the client certificate to authenticate with`,
														},
														"private_key": schema.StringAttribute{
															Computed:    true,
															Description: `the path to the private key of the client certificate`,
														},
														"private_key_passphrase": schema.StringAttribute{
															Computed:    true,
															Description: `the passphrase to use for the private key`,
														},
													},
												},
												"gcp_metadata": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"access_token_path": schema.StringAttribute{
															Computed:    true,
															Description: `the access token metadata path to use`,
														},
														"audience": schema.StringAttribute{
															Computed:    true,
															Description: `the audience to use when fetching identity tokens`,
														},
														"endpoint": schema.StringAttribute{
															Computed:    true,
															Description: `the metadata endpoint to use`,
														},
														"id_token_path": schema.StringAttribute{
															Computed:    true,
															Description: `the identity token metadata path to use`,
														},
														"scopes": schema.ListAttribute{
															Computed:    true,
															ElementType: types.StringType,
															Description: `the set of scopes to use when fetching access token`,
														},
													},
												},
												"oauth2": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"additional_claims": schema.SingleNestedAttribute{
															Computed:    true,
															Description: `map of claims to include in the JWT`,
														},
														"additional_headers": schema.MapAttribute{
															Computed:    true,
															ElementType: types.StringType,
															Description: `map of additional headers to send to token endpoint at the OAuth2 authorization server`,
														},
														"additional_parameters": schema.MapAttribute{
															Computed:    true,
															ElementType: types.StringType,
															Description: `map of additional body parameters to send token endpoint at the OAuth2 authorization server`,
														},
														"client_id": schema.StringAttribute{
															Computed:    true,
															Description: `the client ID to use for authentication`,
														},
														"client_secret": schema.StringAttribute{
															Computed:    true,
															Description: `the client secret to use for authentication`,
														},
														"grant_type": schema.StringAttribute{
															Computed:    true,
															Description: `defaults to client_credentials`,
														},
														"include_jti_claim": schema.BoolAttribute{
															Computed:    true,
															Description: `include a uniquely generated jti claim in any issued JWT`,
														},
														"scopes": schema.ListAttribute{
															Computed:    true,
															ElementType: types.StringType,
															Description: `optional list of scopes to request for the token`,
														},
														"signing_key": schema.StringAttribute{
															Computed:    true,
															Description: `reference to private key used for signing the JWT`,
														},
														"thumbprint": schema.StringAttribute{
															Computed:    true,
															Description: `certificate thumbprint to use for x5t header generation`,
														},
														"token_url": schema.StringAttribute{
															Computed:    true,
															Description: `URL pointing to the token endpoint at the OAuth2 authorization server`,
														},
													},
												},
												"plugin": schema.StringAttribute{
													Computed:    true,
													Description: `authenticate using a custom plugin`,
												},
												"s3_signing": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"environment_credentials": schema.StringAttribute{
															Computed:    true,
															Description: `Parsed as JSON.`,
															Validators: []validator.String{
																validators.IsValidJSON(),
															},
														},
														"metadata_credentials": schema.SingleNestedAttribute{
															Computed: true,
															Attributes: map[string]schema.Attribute{
																"aws_region": schema.StringAttribute{
																	Computed:    true,
																	Description: `the AWS region to use for the AWS signing service credential method`,
																},
																"iam_role": schema.StringAttribute{
																	Computed:    true,
																	Description: `the IAM role to use for the AWS signing service credential method`,
																},
															},
														},
														"profile_credentials": schema.SingleNestedAttribute{
															Computed: true,
															Attributes: map[string]schema.Attribute{
																"aws_region": schema.StringAttribute{
																	Computed:    true,
																	Description: `the AWS region to use for the AWS signing service credential method`,
																},
																"path": schema.StringAttribute{
																	Computed:    true,
																	Description: `the path to the shared credentials file`,
																},
																"profile": schema.StringAttribute{
																	Computed:    true,
																	Description: `AWS Profile to extract credentials from the credentials file`,
																},
															},
														},
														"service": schema.StringAttribute{
															Computed:    true,
															Description: `the AWS service to sign requests with, eg execute-api or s3 (default: s3)`,
														},
														"web_identity_credentials": schema.SingleNestedAttribute{
															Computed: true,
															Attributes: map[string]schema.Attribute{
																"aws_region": schema.StringAttribute{
																	Computed:    true,
																	Description: `the AWS region to use for the sts regional endpoint (default: global)`,
																},
																"session_name": schema.StringAttribute{
																	Computed:    true,
																	Description: `the session name used to identify the assumed role session (default: open-policy-agent)`,
																},
															},
														},
													},
												},
											},
										},
										"headers": schema.MapAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `HTTP headers to include in the requests to the service`,
										},
										"keys": schema.MapNestedAttribute{
											Computed: true,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"algorithm": schema.StringAttribute{
														Computed: true,
													},
													"key": schema.StringAttribute{
														Computed: true,
													},
													"private_key": schema.StringAttribute{
														Computed: true,
													},
													"scope": schema.StringAttribute{
														Computed: true,
													},
												},
											},
											Description: `keys is a dictionary mapping the key name to the actual key and optionally the algorithm and scope.`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `unique name for each service, referred to by plugins`,
										},
										"response_header_timeout_seconds": schema.Int64Attribute{
											Computed:    true,
											Description: `amount of time to wait for a server's response headers after fully writing the request`,
										},
										"tls": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"ca_cert": schema.StringAttribute{
													Computed:    true,
													Description: `the path to the root CA certificate. If not provided, this defaults to TLS using the host’s root CA set`,
												},
												"system_ca_required": schema.BoolAttribute{
													Computed:    true,
													Description: `require system certificate appended with root CA certificate`,
												},
											},
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `optional parameter that allows to use an “OCI” service type`,
										},
										"url": schema.StringAttribute{
											Computed:    true,
											Description: `base URL to contact the service with`,
										},
									},
								},
								Description: `externally configured services`,
							},
						},
					},
					"external_id": schema.StringAttribute{
						Computed:    true,
						Description: `optional parameter to map Styra DAS system ID to external IDs used by a customer. (mapping can be retrieved with TranslateExternalIds operation)`,
					},
					"filter_stacks": schema.BoolAttribute{
						Computed:    true,
						Description: `when set, stacks that are not linked to this system will be filtered out of its bundles`,
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Description: `system ID`,
					},
					"kafka_topic": schema.StringAttribute{
						Computed:    true,
						Description: `optional parameter to specify the Kafka topic where the decision logs for this system should be published (ignored if Kafka is not configured for the workspace for decision export)`,
					},
					"matching_stacks": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `IDs of stacks matching the system`,
					},
					"metadata": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"created_at": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"created_by": schema.StringAttribute{
								Computed: true,
							},
							"created_through": schema.StringAttribute{
								Computed: true,
							},
							"last_modified_at": schema.StringAttribute{
								Computed: true,
								Validators: []validator.String{
									validators.IsRFC3339(),
								},
							},
							"last_modified_by": schema.StringAttribute{
								Computed: true,
							},
							"last_modified_through": schema.StringAttribute{
								Computed: true,
							},
						},
					},
					"migration_history": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"from": schema.StringAttribute{
									Computed: true,
								},
								"initiated_by": schema.StringAttribute{
									Computed: true,
								},
								"initiating_user": schema.StringAttribute{
									Computed: true,
								},
								"migrated_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"recovered": schema.BoolAttribute{
									Computed: true,
								},
								"to": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						Description: `A history of any migrations performed on this system`,
					},
					"minimum_opa_version": schema.StringAttribute{
						Computed:    true,
						Description: `minimum running OPA version for the systems`,
					},
					"mock_opa_enabled": schema.BoolAttribute{
						Computed:    true,
						Description: `enable mock OPAs for this system`,
					},
					"name": schema.StringAttribute{
						Computed:    true,
						Description: `system name`,
					},
					"policies": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"created": schema.StringAttribute{
									Computed:    true,
									Description: `policy on when to (re)generate the policy`,
								},
								"enforcement": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"enforced": schema.BoolAttribute{
											Computed:    true,
											Description: `true if the policy is enforced`,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `enforcement type e.g. opa, test, mask`,
										},
									},
								},
								"id": schema.StringAttribute{
									Computed:    true,
									Description: `policy ID (path)`,
								},
								"modules": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Computed:    true,
												Description: `module name`,
											},
											"placeholder": schema.BoolAttribute{
												Computed:    true,
												Default:     booldefault.StaticBool(false),
												Description: `module is a placeholder. Default: false`,
											},
											"read_only": schema.BoolAttribute{
												Computed:    true,
												Description: `true if module is read-only`,
											},
											"rules": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"allow": schema.Int64Attribute{
														Computed:    true,
														Description: `number of allow rules`,
													},
													"deny": schema.Int64Attribute{
														Computed:    true,
														Description: `number of deny rules`,
													},
													"enforce": schema.Int64Attribute{
														Computed:    true,
														Description: `number of enforce rules`,
													},
													"ignore": schema.Int64Attribute{
														Computed:    true,
														Description: `number of ignore rules`,
													},
													"monitor": schema.Int64Attribute{
														Computed:    true,
														Description: `number of monitor rules`,
													},
													"notify": schema.Int64Attribute{
														Computed:    true,
														Description: `number of notify rules`,
													},
													"other": schema.Int64Attribute{
														Computed:    true,
														Description: `number of unclassified rules`,
													},
													"test": schema.Int64Attribute{
														Computed:    true,
														Description: `number of test rules`,
													},
													"total": schema.Int64Attribute{
														Computed:    true,
														Description: `total number of rules`,
													},
												},
											},
										},
									},
									Description: `rego modules policy consists of`,
								},
								"rules": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"allow": schema.Int64Attribute{
											Computed:    true,
											Description: `number of allow rules`,
										},
										"deny": schema.Int64Attribute{
											Computed:    true,
											Description: `number of deny rules`,
										},
										"enforce": schema.Int64Attribute{
											Computed:    true,
											Description: `number of enforce rules`,
										},
										"ignore": schema.Int64Attribute{
											Computed:    true,
											Description: `number of ignore rules`,
										},
										"monitor": schema.Int64Attribute{
											Computed:    true,
											Description: `number of monitor rules`,
										},
										"notify": schema.Int64Attribute{
											Computed:    true,
											Description: `number of notify rules`,
										},
										"other": schema.Int64Attribute{
											Computed:    true,
											Description: `number of unclassified rules`,
										},
										"test": schema.Int64Attribute{
											Computed:    true,
											Description: `number of test rules`,
										},
										"total": schema.Int64Attribute{
											Computed:    true,
											Description: `total number of rules`,
										},
									},
								},
								"type": schema.StringAttribute{
									Computed:    true,
									Description: `policy type e.g. validating/rules`,
								},
							},
						},
						Description: `policies created for the system`,
					},
					"read_only": schema.BoolAttribute{
						Computed:    true,
						Default:     booldefault.StaticBool(false),
						Description: `prevents users from modifying policies using Styra UIs. Default: false`,
					},
					"source_control": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"origin": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"commit": schema.StringAttribute{
										Computed:    true,
										Description: `Commit SHA. Only one of reference or commit can be set at any time`,
									},
									"credentials": schema.StringAttribute{
										Computed:    true,
										Description: `Credentials are looked under the key <name>/<creds>`,
									},
									"path": schema.StringAttribute{
										Computed:    true,
										Description: `Path to limit the import to`,
									},
									"reference": schema.StringAttribute{
										Computed:    true,
										Description: `Remote reference. Only one of reference or commit can be set at any time`,
									},
									"ssh_credentials": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"passphrase": schema.StringAttribute{
												Computed:    true,
												Description: `Passphrase is looked under the key passphrase/<pass>`,
											},
											"private_key": schema.StringAttribute{
												Computed:    true,
												Description: `PrivateKey is looked under the key private-key/<key>`,
											},
										},
									},
									"url": schema.StringAttribute{
										Computed:    true,
										Description: `Repository URL`,
									},
								},
							},
						},
					},
					"status": schema.StringAttribute{
						Computed:    true,
						Description: `system status`,
					},
					"tokens": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"allow_path_patterns": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"description": schema.StringAttribute{
									Computed: true,
								},
								"expires": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"metadata": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"created_at": schema.StringAttribute{
											Computed: true,
											Validators: []validator.String{
												validators.IsRFC3339(),
											},
										},
										"created_by": schema.StringAttribute{
											Computed: true,
										},
										"created_through": schema.StringAttribute{
											Computed: true,
										},
										"last_modified_at": schema.StringAttribute{
											Computed: true,
											Validators: []validator.String{
												validators.IsRFC3339(),
											},
										},
										"last_modified_by": schema.StringAttribute{
											Computed: true,
										},
										"last_modified_through": schema.StringAttribute{
											Computed: true,
										},
									},
								},
								"token": schema.StringAttribute{
									Computed: true,
								},
								"ttl": schema.StringAttribute{
									Computed: true,
								},
								"uses": schema.Int64Attribute{
									Computed: true,
								},
							},
						},
						Description: `tokens created for the system`,
					},
					"type": schema.StringAttribute{
						Computed:    true,
						Description: `system type e.g. kubernetes`,
					},
					"type_parameters": schema.SingleNestedAttribute{
						Computed:    true,
						Description: `system type parameter values (for template.* types)`,
					},
					"uninstall": schema.MapAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `uninstallation instructions by installation method (deprecated)`,
					},
				},
			},
			"source_control": schema.SingleNestedAttribute{
				Computed: true,
				Optional: true,
				Attributes: map[string]schema.Attribute{
					"origin": schema.SingleNestedAttribute{
						Computed: true,
						Optional: true,
						Attributes: map[string]schema.Attribute{
							"commit": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Commit SHA. Only one of reference or commit can be set at any time. Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"credentials": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Credentials are looked under the key <name>/<creds>. Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"path": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Path to limit the import to. Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"reference": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Remote reference. Only one of reference or commit can be set at any time. Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
							"ssh_credentials": schema.SingleNestedAttribute{
								Computed: true,
								Optional: true,
								Attributes: map[string]schema.Attribute{
									"passphrase": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Description: `Passphrase is looked under the key passphrase/<pass>. Not Null`,
										Validators: []validator.String{
											speakeasy_stringvalidators.NotNull(),
										},
									},
									"private_key": schema.StringAttribute{
										Computed:    true,
										Optional:    true,
										Description: `PrivateKey is looked under the key private-key/<key>. Not Null`,
										Validators: []validator.String{
											speakeasy_stringvalidators.NotNull(),
										},
									},
								},
							},
							"url": schema.StringAttribute{
								Computed:    true,
								Optional:    true,
								Description: `Repository URL. Not Null`,
								Validators: []validator.String{
									speakeasy_stringvalidators.NotNull(),
								},
							},
						},
						Description: `Not Null`,
						Validators: []validator.Object{
							speakeasy_objectvalidators.NotNull(),
						},
					},
				},
			},
			"status": schema.StringAttribute{
				Computed:    true,
				Description: `system status`,
			},
			"tokens": schema.ListNestedAttribute{
				Computed: true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"allow_path_patterns": schema.ListAttribute{
							Computed:    true,
							ElementType: types.StringType,
						},
						"description": schema.StringAttribute{
							Computed: true,
						},
						"expires": schema.StringAttribute{
							Computed: true,
							Validators: []validator.String{
								validators.IsRFC3339(),
							},
						},
						"id": schema.StringAttribute{
							Computed: true,
						},
						"metadata": schema.SingleNestedAttribute{
							Computed: true,
							Attributes: map[string]schema.Attribute{
								"created_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"created_by": schema.StringAttribute{
									Computed: true,
								},
								"created_through": schema.StringAttribute{
									Computed: true,
								},
								"last_modified_at": schema.StringAttribute{
									Computed: true,
									Validators: []validator.String{
										validators.IsRFC3339(),
									},
								},
								"last_modified_by": schema.StringAttribute{
									Computed: true,
								},
								"last_modified_through": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						"token": schema.StringAttribute{
							Computed: true,
						},
						"ttl": schema.StringAttribute{
							Computed: true,
						},
						"uses": schema.Int64Attribute{
							Computed: true,
						},
					},
				},
				Description: `tokens created for the system`,
			},
			"type": schema.StringAttribute{
				Required:    true,
				Description: `system type e.g. kubernetes`,
			},
			"type_parameters": schema.SingleNestedAttribute{
				Computed:    true,
				Optional:    true,
				Description: `system type parameter values (for template.* types)`,
			},
			"uninstall": schema.MapAttribute{
				Computed:    true,
				ElementType: types.StringType,
				Description: `uninstallation instructions by installation method (deprecated)`,
			},
		},
	}
}

func (r *SystemResource) Configure(ctx context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.StyraDas)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *sdk.StyraDas, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *SystemResource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var data *SystemResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(plan.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	request := *data.ToSharedSystemsV1SystemsPostRequest()
	res, err := r.client.Systems.CreateSystem(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.SystemsV1SystemsPostResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedSystemsV1SystemConfig(&res.SystemsV1SystemsPostResponse.Result)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	var id string
	id = data.ID.ValueString()

	request1 := operations.GetSystemRequest{
		ID: id,
	}
	res1, err := r.client.Systems.GetSystem(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.SystemsV1SystemsGetResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromSharedSystemsV1SystemsGetResponse(res1.SystemsV1SystemsGetResponse)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SystemResource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var data *SystemResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var id string
	id = data.ID.ValueString()

	request := operations.GetSystemRequest{
		ID: id,
	}
	res, err := r.client.Systems.GetSystem(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.SystemsV1SystemsGetResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedSystemsV1SystemsGetResponse(res.SystemsV1SystemsGetResponse)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SystemResource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var data *SystemResourceModel
	var plan types.Object

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	merge(ctx, req, resp, &data)
	if resp.Diagnostics.HasError() {
		return
	}

	var id string
	id = data.ID.ValueString()

	systemsV1SystemsPutRequest := *data.ToSharedSystemsV1SystemsPutRequest()
	request := operations.UpdateSystemRequest{
		ID:                         id,
		SystemsV1SystemsPutRequest: systemsV1SystemsPutRequest,
	}
	res, err := r.client.Systems.UpdateSystem(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.SystemsV1SystemsPutResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedSystemsV1SystemConfig(&res.SystemsV1SystemsPutResponse.Result)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)
	var id1 string
	id1 = data.ID.ValueString()

	request1 := operations.GetSystemRequest{
		ID: id1,
	}
	res1, err := r.client.Systems.GetSystem(ctx, request1)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res1 != nil && res1.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res1.RawResponse))
		}
		return
	}
	if res1 == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res1))
		return
	}
	if res1.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res1.StatusCode), debugResponse(res1.RawResponse))
		return
	}
	if !(res1.SystemsV1SystemsGetResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res1.RawResponse))
		return
	}
	data.RefreshFromSharedSystemsV1SystemsGetResponse(res1.SystemsV1SystemsGetResponse)
	refreshPlan(ctx, plan, &data, resp.Diagnostics)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}

func (r *SystemResource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var data *SystemResourceModel
	var item types.Object

	resp.Diagnostics.Append(req.State.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var id string
	id = data.ID.ValueString()

	recursive := new(string)
	if !data.Recursive.IsUnknown() && !data.Recursive.IsNull() {
		*recursive = data.Recursive.ValueString()
	} else {
		recursive = nil
	}
	request := operations.DeleteSystemRequest{
		ID:        id,
		Recursive: recursive,
	}
	res, err := r.client.Systems.DeleteSystem(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}

}

func (r *SystemResource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resp.Diagnostics.Append(resp.State.SetAttribute(ctx, path.Root("id"), req.ID)...)
}
