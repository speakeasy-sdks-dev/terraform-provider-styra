// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"context"
	"fmt"
	tfTypes "github.com/StyraInc/terraform-provider-styra/internal/provider/types"
	"github.com/StyraInc/terraform-provider-styra/internal/sdk"
	"github.com/StyraInc/terraform-provider-styra/internal/sdk/models/operations"
	"github.com/hashicorp/terraform-plugin-framework/datasource"
	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
)

// Ensure provider defined types fully satisfy framework interfaces.
var _ datasource.DataSource = &SystemDataSource{}
var _ datasource.DataSourceWithConfigure = &SystemDataSource{}

func NewSystemDataSource() datasource.DataSource {
	return &SystemDataSource{}
}

// SystemDataSource is the data source implementation.
type SystemDataSource struct {
	client *sdk.StyraDas
}

// SystemDataSourceModel describes the data model.
type SystemDataSourceModel struct {
	ID        types.String                  `tfsdk:"id"`
	RequestID types.String                  `tfsdk:"request_id"`
	Result    tfTypes.SystemsV1SystemConfig `tfsdk:"result"`
}

// Metadata returns the data source type name.
func (r *SystemDataSource) Metadata(ctx context.Context, req datasource.MetadataRequest, resp *datasource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_system"
}

// Schema defines the schema for the data source.
func (r *SystemDataSource) Schema(ctx context.Context, req datasource.SchemaRequest, resp *datasource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: "System DataSource",

		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Required:    true,
				Description: `system ID`,
			},
			"request_id": schema.StringAttribute{
				Computed: true,
			},
			"result": schema.SingleNestedAttribute{
				Computed: true,
				Attributes: map[string]schema.Attribute{
					"authz": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"role_bindings": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"id": schema.StringAttribute{
											Computed:    true,
											Description: `role binding ID`,
										},
										"role_name": schema.StringAttribute{
											Computed:    true,
											Description: `role name`,
										},
									},
								},
								Description: `a list of role binding configs`,
							},
						},
					},
					"bundle_download": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"delta_bundles": schema.BoolAttribute{
								Computed:    true,
								Description: `enabled delta bundles on bundle download`,
							},
						},
					},
					"bundle_registry": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"disable_bundle_compatibility_check": schema.BoolAttribute{
								Computed:    true,
								Description: `when checked, bundles will be activated regardless of their compatibility with currently running agents`,
							},
							"distribution_s3": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"access_keys": schema.StringAttribute{
										Computed:    true,
										Description: `access key id and secret access key are looked under the key <name>/<access_keys>`,
									},
									"bucket": schema.StringAttribute{
										Computed:    true,
										Description: `bucket name`,
									},
									"context_path": schema.StringAttribute{
										Computed:    true,
										Description: `context bundle path. The name must not use template variables`,
									},
									"discovery_path": schema.StringAttribute{
										Computed:    true,
										Description: `discovery bundle path. Template variables can be used in the name`,
									},
									"endpoint": schema.StringAttribute{
										Computed:    true,
										Description: `AWS endpoint`,
									},
									"opa_credentials": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"environment_credentials": schema.SingleNestedAttribute{
												Computed: true,
											},
											"metadata_credentials": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"aws_region": schema.StringAttribute{
														Computed: true,
													},
													"iam_role": schema.StringAttribute{
														Computed: true,
													},
												},
											},
											"web_identity_credentials": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"aws_region": schema.StringAttribute{
														Computed: true,
													},
													"session_name": schema.StringAttribute{
														Computed: true,
													},
												},
											},
										},
									},
									"policy_path": schema.StringAttribute{
										Computed:    true,
										Description: `policy bundle path. Template variables can be used in the name`,
									},
									"region": schema.StringAttribute{
										Computed:    true,
										Description: `AWS region`,
									},
									"role_arn": schema.StringAttribute{
										Computed:    true,
										Description: `AWS role`,
									},
								},
							},
							"entrypoints": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `extra bundle entry points to use when compiling bundles`,
							},
							"manual_deployment": schema.BoolAttribute{
								Computed:    true,
								Description: `manual deployment mode to prevent automatic deployment of new bundles`,
							},
							"manual_deployment_overrides": schema.MapAttribute{
								Computed:    true,
								ElementType: types.BoolType,
								Description: `Override of manual deployment mode flag per bundle type`,
							},
							"max_bundles": schema.Int64Attribute{
								Computed:    true,
								Description: `maximum number of all bundles to store`,
							},
							"max_deployed_bundles": schema.Int64Attribute{
								Computed:    true,
								Description: `maximum number of previously deployed bundles to store`,
							},
							"optimization_level": schema.Int64Attribute{
								Computed:    true,
								Description: `OPA optimization level to use when building bundles`,
							},
						},
					},
					"context_bundle_data_only": schema.BoolAttribute{
						Computed:    true,
						Description: `only put data in the context bundle`,
					},
					"context_bundle_roots": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `list of path prefixes for policies/datasources that go into the second (context) bundle`,
					},
					"datasources": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"category": schema.StringAttribute{
									Computed:    true,
									Description: `datasource category`,
								},
								"id": schema.StringAttribute{
									Computed:    true,
									Description: `datasource ID`,
								},
								"optional": schema.BoolAttribute{
									Computed:    true,
									Description: `optional datasources can be deleted without being recreated automatically`,
								},
								"status": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"code": schema.StringAttribute{
											Computed: true,
										},
										"message": schema.StringAttribute{
											Computed: true,
										},
										"timestamp": schema.StringAttribute{
											Computed: true,
										},
									},
								},
							},
						},
						Description: `datasources created for the system`,
					},
					"decision_mappings": schema.MapNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"allowed": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"expected": schema.StringAttribute{
											Computed:    true,
											Description: `Parsed as JSON.`,
										},
										"negated": schema.BoolAttribute{
											Computed:    true,
											Description: `when set to true, decision is Allowed when the mapped property IS NOT equal to the expected value`,
										},
										"path": schema.StringAttribute{
											Computed:    true,
											Description: `dot-separated decision property path`,
										},
									},
								},
								"columns": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"key": schema.StringAttribute{
												Computed:    true,
												Description: `column key (also the search key)`,
											},
											"path": schema.StringAttribute{
												Computed:    true,
												Description: `dot-separated decision property path`,
											},
											"type": schema.StringAttribute{
												Computed:    true,
												Description: `column type: one of "string", "boolean", "date", "integer", "float"`,
											},
										},
									},
									Description: `decision mappings for additional columns`,
								},
								"reason": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"path": schema.StringAttribute{
											Computed:    true,
											Description: `dot-separated decision property path`,
										},
									},
								},
							},
						},
						Description: `location of key attributes and additional columns in the decisions grouped by policy entry point path`,
					},
					"deployment_parameters": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"deny_on_opa_fail": schema.BoolAttribute{
								Computed:    true,
								Description: `true to fail close`,
							},
							"discovery": schema.SingleNestedAttribute{
								Computed:    true,
								Description: `discovery config settings for OPAs linked to the system. (in case of conflict with system-type defined setting, this value takes precedence)`,
							},
							"extra": schema.SingleNestedAttribute{
								Computed:    true,
								Description: `extra deployment settings`,
							},
							"http_proxy": schema.StringAttribute{
								Computed:    true,
								Description: `HTTP proxy URL`,
							},
							"https_proxy": schema.StringAttribute{
								Computed:    true,
								Description: `HTTPS proxy URL`,
							},
							"kubernetes_version": schema.StringAttribute{
								Computed:    true,
								Description: `minimum Kubernetes version expected (where applicable)`,
							},
							"mutating_webhook_name": schema.StringAttribute{
								Computed:    true,
								Description: `Custom name for mutating webhook (useful for changing webhook order of execution)`,
							},
							"namespace": schema.StringAttribute{
								Computed:    true,
								Description: `Kubernetes namespace the system is deployed to`,
							},
							"no_proxy": schema.StringAttribute{
								Computed:    true,
								Description: `URLs that should be excluded from proxying`,
							},
							"timeout_seconds": schema.Int64Attribute{
								Computed:    true,
								Description: `Kubernetes webhook timeout (where applicable)`,
							},
							"trusted_ca_certs": schema.ListAttribute{
								Computed:    true,
								ElementType: types.StringType,
								Description: `trusted CA certificates`,
							},
							"trusted_container_registry": schema.StringAttribute{
								Computed:    true,
								Description: `trusted container registry`,
							},
						},
					},
					"description": schema.StringAttribute{
						Computed:    true,
						Description: `description for the system`,
					},
					"error_setting": schema.StringAttribute{
						Computed:    true,
						Description: `error/warning configuration: one of "all", "errors", "none"`,
					},
					"errors": schema.MapNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"errors": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"code": schema.StringAttribute{
												Computed: true,
											},
											"message": schema.StringAttribute{
												Computed: true,
											},
											"timestamp": schema.StringAttribute{
												Computed: true,
											},
										},
									},
									Description: `list of system errors`,
								},
								"waiting": schema.BoolAttribute{
									Computed:    true,
									Description: `true if the the system is waiting for error to be resolved`,
								},
							},
						},
						Description: `current deployment errors`,
					},
					"external_bundles": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"bundles": schema.MapNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"persist": schema.BoolAttribute{
											Computed:    true,
											Description: `persist activated bundles to disk`,
										},
										"polling": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"long_polling_timeout_seconds": schema.Int64Attribute{
													Computed:    true,
													Description: `maximum amount of time the server should wait before issuing a timeout if there’s no update available`,
												},
												"max_delay_seconds": schema.Int64Attribute{
													Computed:    true,
													Description: `maximum amount of time to wait between bundle downloads`,
												},
												"min_delay_seconds": schema.Int64Attribute{
													Computed:    true,
													Description: `minimum amount of time to wait between bundle downloads`,
												},
											},
										},
										"resource": schema.StringAttribute{
											Computed:    true,
											Description: `resource path to use to download bundle from configured service`,
										},
										"service": schema.StringAttribute{
											Computed:    true,
											Description: `name of service to use to contact remote server`,
										},
										"signing": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"exclude_files": schema.ListAttribute{
													Computed:    true,
													ElementType: types.StringType,
													Description: `files in the bundle to exclude during verification`,
												},
												"keyid": schema.StringAttribute{
													Computed:    true,
													Description: `name of the key to use for bundle signature verification`,
												},
												"public_keys": schema.MapNestedAttribute{
													Computed: true,
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"algorithm": schema.StringAttribute{
																Computed:    true,
																Description: `name of the signing algorithm`,
															},
															"key": schema.StringAttribute{
																Computed:    true,
																Description: `PEM encoded public key to use for signature verification`,
															},
															"private_key": schema.StringAttribute{
																Computed:    true,
																Description: `PEM encoded private key to use for signing`,
															},
															"scope": schema.StringAttribute{
																Computed:    true,
																Description: `scope to use for bundle signature verification`,
															},
														},
													},
													Description: `information about necessary public signing keys`,
												},
												"scope": schema.StringAttribute{
													Computed:    true,
													Description: `scope to use for bundle signature verification`,
												},
											},
										},
										"size_limit_bytes": schema.Int64Attribute{
											Computed:    true,
											Description: `size limit for individual files contained in the bundle`,
										},
									},
								},
								Description: `externally configured bundles, use name of bundle as key`,
							},
							"services": schema.ListNestedAttribute{
								Computed: true,
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"allow_insecure_tls": schema.BoolAttribute{
											Computed:    true,
											Description: `allow insecure TLS`,
										},
										"credentials": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"azure_managed_identity": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"api_version": schema.StringAttribute{
															Computed:    true,
															Description: `API version to use`,
														},
														"client_id": schema.StringAttribute{
															Computed:    true,
															Description: `optional client ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities`,
														},
														"endpoint": schema.StringAttribute{
															Computed:    true,
															Description: `request endpoint`,
														},
														"mi_res_id": schema.StringAttribute{
															Computed:    true,
															Description: `optional Azure Resource ID of the managed identity you would like the token for, required, if your VM has multiple user-assigned managed identities`,
														},
														"object_id": schema.StringAttribute{
															Computed:    true,
															Description: `optional object ID of the managed identity you would like the token for, required if your VM has multiple user-assigned managed identities`,
														},
														"resource": schema.StringAttribute{
															Computed:    true,
															Description: `app ID URI of the target resource`,
														},
													},
												},
												"bearer": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"scheme": schema.StringAttribute{
															Computed:    true,
															Description: `bearer token scheme to specify`,
														},
														"token": schema.StringAttribute{
															Computed:    true,
															Description: `enables token-based authentication and supplies the bearer token to authenticate with`,
														},
														"token_path": schema.StringAttribute{
															Computed:    true,
															Description: `enables token-based authentication and supplies the path to the bearer token to authenticate with`,
														},
													},
												},
												"client_tls": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"cert": schema.StringAttribute{
															Computed:    true,
															Description: `the path to the client certificate to authenticate with`,
														},
														"private_key": schema.StringAttribute{
															Computed:    true,
															Description: `the path to the private key of the client certificate`,
														},
														"private_key_passphrase": schema.StringAttribute{
															Computed:    true,
															Description: `the passphrase to use for the private key`,
														},
													},
												},
												"gcp_metadata": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"access_token_path": schema.StringAttribute{
															Computed:    true,
															Description: `the access token metadata path to use`,
														},
														"audience": schema.StringAttribute{
															Computed:    true,
															Description: `the audience to use when fetching identity tokens`,
														},
														"endpoint": schema.StringAttribute{
															Computed:    true,
															Description: `the metadata endpoint to use`,
														},
														"id_token_path": schema.StringAttribute{
															Computed:    true,
															Description: `the identity token metadata path to use`,
														},
														"scopes": schema.ListAttribute{
															Computed:    true,
															ElementType: types.StringType,
															Description: `the set of scopes to use when fetching access token`,
														},
													},
												},
												"oauth2": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"additional_claims": schema.SingleNestedAttribute{
															Computed:    true,
															Description: `map of claims to include in the JWT`,
														},
														"additional_headers": schema.MapAttribute{
															Computed:    true,
															ElementType: types.StringType,
															Description: `map of additional headers to send to token endpoint at the OAuth2 authorization server`,
														},
														"additional_parameters": schema.MapAttribute{
															Computed:    true,
															ElementType: types.StringType,
															Description: `map of additional body parameters to send token endpoint at the OAuth2 authorization server`,
														},
														"client_id": schema.StringAttribute{
															Computed:    true,
															Description: `the client ID to use for authentication`,
														},
														"client_secret": schema.StringAttribute{
															Computed:    true,
															Description: `the client secret to use for authentication`,
														},
														"grant_type": schema.StringAttribute{
															Computed:    true,
															Description: `defaults to client_credentials`,
														},
														"include_jti_claim": schema.BoolAttribute{
															Computed:    true,
															Description: `include a uniquely generated jti claim in any issued JWT`,
														},
														"scopes": schema.ListAttribute{
															Computed:    true,
															ElementType: types.StringType,
															Description: `optional list of scopes to request for the token`,
														},
														"signing_key": schema.StringAttribute{
															Computed:    true,
															Description: `reference to private key used for signing the JWT`,
														},
														"thumbprint": schema.StringAttribute{
															Computed:    true,
															Description: `certificate thumbprint to use for x5t header generation`,
														},
														"token_url": schema.StringAttribute{
															Computed:    true,
															Description: `URL pointing to the token endpoint at the OAuth2 authorization server`,
														},
													},
												},
												"plugin": schema.StringAttribute{
													Computed:    true,
													Description: `authenticate using a custom plugin`,
												},
												"s3_signing": schema.SingleNestedAttribute{
													Computed: true,
													Attributes: map[string]schema.Attribute{
														"environment_credentials": schema.StringAttribute{
															Computed:    true,
															Description: `Parsed as JSON.`,
														},
														"metadata_credentials": schema.SingleNestedAttribute{
															Computed: true,
															Attributes: map[string]schema.Attribute{
																"aws_region": schema.StringAttribute{
																	Computed:    true,
																	Description: `the AWS region to use for the AWS signing service credential method`,
																},
																"iam_role": schema.StringAttribute{
																	Computed:    true,
																	Description: `the IAM role to use for the AWS signing service credential method`,
																},
															},
														},
														"profile_credentials": schema.SingleNestedAttribute{
															Computed: true,
															Attributes: map[string]schema.Attribute{
																"aws_region": schema.StringAttribute{
																	Computed:    true,
																	Description: `the AWS region to use for the AWS signing service credential method`,
																},
																"path": schema.StringAttribute{
																	Computed:    true,
																	Description: `the path to the shared credentials file`,
																},
																"profile": schema.StringAttribute{
																	Computed:    true,
																	Description: `AWS Profile to extract credentials from the credentials file`,
																},
															},
														},
														"service": schema.StringAttribute{
															Computed:    true,
															Description: `the AWS service to sign requests with, eg execute-api or s3 (default: s3)`,
														},
														"web_identity_credentials": schema.SingleNestedAttribute{
															Computed: true,
															Attributes: map[string]schema.Attribute{
																"aws_region": schema.StringAttribute{
																	Computed:    true,
																	Description: `the AWS region to use for the sts regional endpoint (default: global)`,
																},
																"session_name": schema.StringAttribute{
																	Computed:    true,
																	Description: `the session name used to identify the assumed role session (default: open-policy-agent)`,
																},
															},
														},
													},
												},
											},
										},
										"headers": schema.MapAttribute{
											Computed:    true,
											ElementType: types.StringType,
											Description: `HTTP headers to include in the requests to the service`,
										},
										"keys": schema.MapNestedAttribute{
											Computed: true,
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"algorithm": schema.StringAttribute{
														Computed: true,
													},
													"key": schema.StringAttribute{
														Computed: true,
													},
													"private_key": schema.StringAttribute{
														Computed: true,
													},
													"scope": schema.StringAttribute{
														Computed: true,
													},
												},
											},
											Description: `keys is a dictionary mapping the key name to the actual key and optionally the algorithm and scope.`,
										},
										"name": schema.StringAttribute{
											Computed:    true,
											Description: `unique name for each service, referred to by plugins`,
										},
										"response_header_timeout_seconds": schema.Int64Attribute{
											Computed:    true,
											Description: `amount of time to wait for a server's response headers after fully writing the request`,
										},
										"tls": schema.SingleNestedAttribute{
											Computed: true,
											Attributes: map[string]schema.Attribute{
												"ca_cert": schema.StringAttribute{
													Computed:    true,
													Description: `the path to the root CA certificate. If not provided, this defaults to TLS using the host’s root CA set`,
												},
												"system_ca_required": schema.BoolAttribute{
													Computed:    true,
													Description: `require system certificate appended with root CA certificate`,
												},
											},
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `optional parameter that allows to use an “OCI” service type`,
										},
										"url": schema.StringAttribute{
											Computed:    true,
											Description: `base URL to contact the service with`,
										},
									},
								},
								Description: `externally configured services`,
							},
						},
					},
					"external_id": schema.StringAttribute{
						Computed:    true,
						Description: `optional parameter to map Styra DAS system ID to external IDs used by a customer. (mapping can be retrieved with TranslateExternalIds operation)`,
					},
					"filter_stacks": schema.BoolAttribute{
						Computed:    true,
						Description: `when set, stacks that are not linked to this system will be filtered out of its bundles`,
					},
					"id": schema.StringAttribute{
						Computed:    true,
						Description: `system ID`,
					},
					"kafka_topic": schema.StringAttribute{
						Computed:    true,
						Description: `optional parameter to specify the Kafka topic where the decision logs for this system should be published (ignored if Kafka is not configured for the workspace for decision export)`,
					},
					"matching_stacks": schema.ListAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `IDs of stacks matching the system`,
					},
					"metadata": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"created_at": schema.StringAttribute{
								Computed: true,
							},
							"created_by": schema.StringAttribute{
								Computed: true,
							},
							"created_through": schema.StringAttribute{
								Computed: true,
							},
							"last_modified_at": schema.StringAttribute{
								Computed: true,
							},
							"last_modified_by": schema.StringAttribute{
								Computed: true,
							},
							"last_modified_through": schema.StringAttribute{
								Computed: true,
							},
						},
					},
					"migration_history": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"from": schema.StringAttribute{
									Computed: true,
								},
								"initiated_by": schema.StringAttribute{
									Computed: true,
								},
								"initiating_user": schema.StringAttribute{
									Computed: true,
								},
								"migrated_at": schema.StringAttribute{
									Computed: true,
								},
								"recovered": schema.BoolAttribute{
									Computed: true,
								},
								"to": schema.StringAttribute{
									Computed: true,
								},
							},
						},
						Description: `A history of any migrations performed on this system`,
					},
					"minimum_opa_version": schema.StringAttribute{
						Computed:    true,
						Description: `minimum running OPA version for the systems`,
					},
					"mock_opa_enabled": schema.BoolAttribute{
						Computed:    true,
						Description: `enable mock OPAs for this system`,
					},
					"name": schema.StringAttribute{
						Computed:    true,
						Description: `system name`,
					},
					"policies": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"created": schema.StringAttribute{
									Computed:    true,
									Description: `policy on when to (re)generate the policy`,
								},
								"enforcement": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"enforced": schema.BoolAttribute{
											Computed:    true,
											Description: `true if the policy is enforced`,
										},
										"type": schema.StringAttribute{
											Computed:    true,
											Description: `enforcement type e.g. opa, test, mask`,
										},
									},
								},
								"id": schema.StringAttribute{
									Computed:    true,
									Description: `policy ID (path)`,
								},
								"modules": schema.ListNestedAttribute{
									Computed: true,
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Computed:    true,
												Description: `module name`,
											},
											"placeholder": schema.BoolAttribute{
												Computed:    true,
												Description: `module is a placeholder`,
											},
											"read_only": schema.BoolAttribute{
												Computed:    true,
												Description: `true if module is read-only`,
											},
											"rules": schema.SingleNestedAttribute{
												Computed: true,
												Attributes: map[string]schema.Attribute{
													"allow": schema.Int64Attribute{
														Computed:    true,
														Description: `number of allow rules`,
													},
													"deny": schema.Int64Attribute{
														Computed:    true,
														Description: `number of deny rules`,
													},
													"enforce": schema.Int64Attribute{
														Computed:    true,
														Description: `number of enforce rules`,
													},
													"ignore": schema.Int64Attribute{
														Computed:    true,
														Description: `number of ignore rules`,
													},
													"monitor": schema.Int64Attribute{
														Computed:    true,
														Description: `number of monitor rules`,
													},
													"notify": schema.Int64Attribute{
														Computed:    true,
														Description: `number of notify rules`,
													},
													"other": schema.Int64Attribute{
														Computed:    true,
														Description: `number of unclassified rules`,
													},
													"test": schema.Int64Attribute{
														Computed:    true,
														Description: `number of test rules`,
													},
													"total": schema.Int64Attribute{
														Computed:    true,
														Description: `total number of rules`,
													},
												},
											},
										},
									},
									Description: `rego modules policy consists of`,
								},
								"rules": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"allow": schema.Int64Attribute{
											Computed:    true,
											Description: `number of allow rules`,
										},
										"deny": schema.Int64Attribute{
											Computed:    true,
											Description: `number of deny rules`,
										},
										"enforce": schema.Int64Attribute{
											Computed:    true,
											Description: `number of enforce rules`,
										},
										"ignore": schema.Int64Attribute{
											Computed:    true,
											Description: `number of ignore rules`,
										},
										"monitor": schema.Int64Attribute{
											Computed:    true,
											Description: `number of monitor rules`,
										},
										"notify": schema.Int64Attribute{
											Computed:    true,
											Description: `number of notify rules`,
										},
										"other": schema.Int64Attribute{
											Computed:    true,
											Description: `number of unclassified rules`,
										},
										"test": schema.Int64Attribute{
											Computed:    true,
											Description: `number of test rules`,
										},
										"total": schema.Int64Attribute{
											Computed:    true,
											Description: `total number of rules`,
										},
									},
								},
								"type": schema.StringAttribute{
									Computed:    true,
									Description: `policy type e.g. validating/rules`,
								},
							},
						},
						Description: `policies created for the system`,
					},
					"read_only": schema.BoolAttribute{
						Computed:    true,
						Description: `prevents users from modifying policies using Styra UIs`,
					},
					"source_control": schema.SingleNestedAttribute{
						Computed: true,
						Attributes: map[string]schema.Attribute{
							"origin": schema.SingleNestedAttribute{
								Computed: true,
								Attributes: map[string]schema.Attribute{
									"commit": schema.StringAttribute{
										Computed:    true,
										Description: `Commit SHA. Only one of reference or commit can be set at any time`,
									},
									"credentials": schema.StringAttribute{
										Computed:    true,
										Description: `Credentials are looked under the key <name>/<creds>`,
									},
									"path": schema.StringAttribute{
										Computed:    true,
										Description: `Path to limit the import to`,
									},
									"reference": schema.StringAttribute{
										Computed:    true,
										Description: `Remote reference. Only one of reference or commit can be set at any time`,
									},
									"ssh_credentials": schema.SingleNestedAttribute{
										Computed: true,
										Attributes: map[string]schema.Attribute{
											"passphrase": schema.StringAttribute{
												Computed:    true,
												Description: `Passphrase is looked under the key passphrase/<pass>`,
											},
											"private_key": schema.StringAttribute{
												Computed:    true,
												Description: `PrivateKey is looked under the key private-key/<key>`,
											},
										},
									},
									"url": schema.StringAttribute{
										Computed:    true,
										Description: `Repository URL`,
									},
								},
							},
						},
					},
					"status": schema.StringAttribute{
						Computed:    true,
						Description: `system status`,
					},
					"tokens": schema.ListNestedAttribute{
						Computed: true,
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"allow_path_patterns": schema.ListAttribute{
									Computed:    true,
									ElementType: types.StringType,
								},
								"description": schema.StringAttribute{
									Computed: true,
								},
								"expires": schema.StringAttribute{
									Computed: true,
								},
								"id": schema.StringAttribute{
									Computed: true,
								},
								"metadata": schema.SingleNestedAttribute{
									Computed: true,
									Attributes: map[string]schema.Attribute{
										"created_at": schema.StringAttribute{
											Computed: true,
										},
										"created_by": schema.StringAttribute{
											Computed: true,
										},
										"created_through": schema.StringAttribute{
											Computed: true,
										},
										"last_modified_at": schema.StringAttribute{
											Computed: true,
										},
										"last_modified_by": schema.StringAttribute{
											Computed: true,
										},
										"last_modified_through": schema.StringAttribute{
											Computed: true,
										},
									},
								},
								"token": schema.StringAttribute{
									Computed: true,
								},
								"ttl": schema.StringAttribute{
									Computed: true,
								},
								"uses": schema.Int64Attribute{
									Computed: true,
								},
							},
						},
						Description: `tokens created for the system`,
					},
					"type": schema.StringAttribute{
						Computed:    true,
						Description: `system type e.g. kubernetes`,
					},
					"type_parameters": schema.SingleNestedAttribute{
						Computed:    true,
						Description: `system type parameter values (for template.* types)`,
					},
					"uninstall": schema.MapAttribute{
						Computed:    true,
						ElementType: types.StringType,
						Description: `uninstallation instructions by installation method (deprecated)`,
					},
				},
			},
		},
	}
}

func (r *SystemDataSource) Configure(ctx context.Context, req datasource.ConfigureRequest, resp *datasource.ConfigureResponse) {
	// Prevent panic if the provider has not been configured.
	if req.ProviderData == nil {
		return
	}

	client, ok := req.ProviderData.(*sdk.StyraDas)

	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected DataSource Configure Type",
			fmt.Sprintf("Expected *sdk.StyraDas, got: %T. Please report this issue to the provider developers.", req.ProviderData),
		)

		return
	}

	r.client = client
}

func (r *SystemDataSource) Read(ctx context.Context, req datasource.ReadRequest, resp *datasource.ReadResponse) {
	var data *SystemDataSourceModel
	var item types.Object

	resp.Diagnostics.Append(req.Config.Get(ctx, &item)...)
	if resp.Diagnostics.HasError() {
		return
	}

	resp.Diagnostics.Append(item.As(ctx, &data, basetypes.ObjectAsOptions{
		UnhandledNullAsEmpty:    true,
		UnhandledUnknownAsEmpty: true,
	})...)

	if resp.Diagnostics.HasError() {
		return
	}

	var id string
	id = data.ID.ValueString()

	request := operations.GetSystemRequest{
		ID: id,
	}
	res, err := r.client.Systems.GetSystem(ctx, request)
	if err != nil {
		resp.Diagnostics.AddError("failure to invoke API", err.Error())
		if res != nil && res.RawResponse != nil {
			resp.Diagnostics.AddError("unexpected http request/response", debugResponse(res.RawResponse))
		}
		return
	}
	if res == nil {
		resp.Diagnostics.AddError("unexpected response from API", fmt.Sprintf("%v", res))
		return
	}
	if res.StatusCode == 404 {
		resp.State.RemoveResource(ctx)
		return
	}
	if res.StatusCode != 200 {
		resp.Diagnostics.AddError(fmt.Sprintf("unexpected response from API. Got an unexpected response code %v", res.StatusCode), debugResponse(res.RawResponse))
		return
	}
	if !(res.SystemsV1SystemsGetResponse != nil) {
		resp.Diagnostics.AddError("unexpected response from API. Got an unexpected response body", debugResponse(res.RawResponse))
		return
	}
	data.RefreshFromSharedSystemsV1SystemsGetResponse(res.SystemsV1SystemsGetResponse)

	// Save updated data into Terraform state
	resp.Diagnostics.Append(resp.State.Set(ctx, &data)...)
}
